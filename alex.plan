<!--- -*- mode: Markdown; var: -*- -->
# 2024-05-12T19:18:39-0700

Remembering some bits of x86 assembly with AT&T syntax:

- `lea <mem>, <reg32>` loads effective address, places the address
  specified by the 
  first operand into the register specified by the second operand
- `mov` moves data referred by the first operand into the location given
  by the second operand
- `rbp` is the frame base pointer [hence "bp"] in x86-64, `rsp` is the
  stack pointer [hence "sp"]
- `symbol@GOTOFF` addresses the variable itself, relative to the GOT
  base (a convenient but arbitrary choice of anchor). This usually
  appears as the first operand in a `leal` instruction in a lot of
  disassembly. 

# 2024-05-12T11:58:44-0700

So this should conclude the parsing of expressions, which means I can
begin parsing statements. I should really spend more time writing unit
tests for all possible expressions in Fortran, but I'm mildly confident
it works fine.

# 2024-05-12T09:35:00-0700

It dawns on me that I am going to need to parse `write (*,*) <iolist>`
and `read (*,*) <iolist>` specially. Fortunately I have `Read` and
`Write` as special tokens.

And Fortran has some peculiar quirks concerning dummy arguments (which
are `*` passed as function arguments).

```ebnf
array-or-funcall = funcall | array-element-or-slice;

funcall = identifier "(" ")"
        | identifier "(" expr {, expr} ")" ;

(* R612 and R613 *)
data-ref = identifier
         | identifier "(" section-subscript {"," section-subscript} ")" ;

(* R615 *)
array-element = data-ref;

(* R616 *)
array-section = data-ref
              | data-ref "(" [scalar-int-expr] ":" [scalar-int-expr] ")";

subscript = int-scalar-expr; (* R617 *)

(* R618 *)
section-subscript = subscript
                   | subscript-triplet
                   | vector-subscript;
subscript-triplet = [subscript] ":" [subscript] [":" stride]; (* R619 *)
stride = scalar-int-expr; (* R620 *)
```

Some examples:
- `A(x)` is an array element
- `A(1, 2)` is an array element
- `A(1:N:2, M)` is a rank-one array section
- `B(:,:,:)` is an array section when `B` is an array of rank-3
- `A(3:5,2,1:2)` is an array section with shape `(3,2)`

# 2024-05-12T09:20:58-0700

I caught a bug with `Parser::consume()` which was silly. I also caught a
bug with scanning an identifier, thanks to trying to parse function
names --- `f()` was scanned as `Identifier::("f(")` followed by `RightParen`.
It's good that I am unit testing as I go along, otherwise I would never
catch these bugs!

So far I have supported variables and "simple" function calls (i.e.,
function calls requiring no arguments). The next task is
arrays. This...well, it's going to be a horrible mess.

# 2024-05-12T08:35:56-0700

After adding support for variables, I looked around and found Frank
Lhota wrote a
[Flex/Bison parser](https://github.com/FrankLhota56/fortran66-flex/) 
for FORTRAN 66. It's interesting to see what 
the grammar looks like. It appears much simpler in some regards. Well,
the [FORTRAN 66 Standard](https://wg5-fortran.org/ARCHIVE/Fortran66.pdf)
is merely 39 pages (compared to the 223 pages for FORTRAN 77) and arrays
were limited to be of rank no greater than 3. Array slices were not a
"thing" in FORTRAN 66.

In FORTRAN 77, array slices weren't really part of the Standard
either. But substrings were specified using colons (e.g., `NAME(3:17)`).

So now I have a decision to make, I can:

1. Adhere to the FORTRAN 77 Standard and only support array slices for
   strings, or
2. Support Fortran 90 array slices in general.

It seems that the second choice is more general and easier to implement. 

# 2024-05-12T07:21:58-0700

I am planning to work out a few more unit tests, to make sure that the
parser is parsing expressions as intended.

I have added the grammar rules for expressions as comments, to remind
myself of what each function is supposed to do.

My current plan:
- [ ] Unit test more expressions
- [ ] Parse named data references

## Named Data References

This term seems to be used in the Fortran 90 grammars. Broadly, it
refers to:

- variables
- function calls
- array elements

The FORTRAN 77 Standard 6.1.2.1 defines a primary expression as
consisting of:

> 1. Unsigned arithmetic constant (4.2.3)
> 2. Symbolic name of an arithmetic constant (8.6)
> 3. Arithmetic variable reference (2.5)
> 4. Arithmetic array element reference (5.3)
> 5. Arithmetic function reference (15.2)
> 6. Arithmetic expression  enclosed  in  parentheses (6.1.2.4)

This is the archaic terminology for:

1. number literals
2. `parameter` constants
3. variables
4. array element name
5. function call
6. literally the `"(" expression ")"` rule

We have handled cases 1 and 6. "Named data references" must therefore
include cases 2 through 5.

### Variables

A variable is simply an identifier which is not followed by a left
parentheses (otherwise it would either be a function call or an array
element). 

### Function Calls

From the Fortran 90 grammars I have seen, usually the rule for a
function call is simply:

```enbf
function-reference = name "(" ")";
```

That is to say, it is a function invocation with zero parameters. This
is because we **know** it cannot possibly be an array element.

Function calls with arguments passed in, well, they're parsed using the
same rules as array element names, and then later determined to be
function calls or not. At least, that's the way it appears to me.

### Array Element Name

The grammar for an array element name looks like the following EBNF
grammar (according to sections 5.3 and 5.4 of the 77 Standard):

```ebnf
array-element-name = identifier "(" subscript-expr-list ")";

subscript-expr-list = subscript-expr {"," subscript-expr };

subscript-expr = int-literal
               | identifer;
```

However, in Section 6.2.2 of the 90 Standard, it allows array sections
(which is a cleaner way to organize the same results in the 77
Standard):

```ebnf
(* R611 *)
substring-range = [scalar-int-expr] ":" [scalar-int-expr] ;

(* R612 *)
data-ref = part-ref { "%" part-ref };

(* R613 *)
part-ref = part-name [ "(" section-subscript-list ")" ];
(* Constraint: in a `data-ref`, each `part-name` except the rightmost must
               be of a derived type. *)
(* Constraint: in a `data-ref`, each `part-name` except the leftmost must
               be the name of a component of the derived type
               definition of the type of the preceding `part-name`. *)
(* Constraint: in a `part-ref` containing a `section-subscript-list`, the
               number of `section-subscript`s must equal the rank of 
               `part-name`. *)
(* Constraint: in a `data-ref`, there must not be more than one `part-ref`
               with nonzero rank. A `part-name` to the right of a
               `part-ref` with nonzero rank must not have the POINTER
               attribute. *)

(* R614 *)
structure-component = data-ref; (* irrelevant for F77 *)

(* R615 *)
array-element = data-ref;
(* Constraint: in an array-element, every part-ref must have rank zero
               and the last part-ref must contain a subscript-list. *)

(* R616 *)
array-section = data-ref [ "(" substring-range ")" ] ;
(* Constraint: In array-section, exactly one part-ref must have nonzero rank,
               and either the final part-ref has a section-subscript-list
               with nonzero rank or another part-ref has a nonzero rank. *)
(* Constraint: In an array-section with a substring-range, the rightmost
               part-name must be of type character. *)

(* R617 *)
subscript = scalar-int-expr ;

(* R618 *)
section-subscript = subscript
                  | subscript-triplet
                  | vector-subscript ;

(* R619 *)
subscript-triplet = [subscript] ":" [subscript] [":" stride] ;

(* R620 *)
stride = scalar-int-expr ;

(* R621 *)
vector-subscript = int-expr ;
(* Constraint: vector-subscript must be  an integer array expression of
               rank 1 *)
```

Since there are no structures in F77, this simplifies to the following
grammar:

```ebnf
(* R611 *)
substring-range = [scalar-int-expr] ":" [scalar-int-expr] ;

(* R612 through R614, contracted *)
data-ref = part-name [ "(" section-subscript-list ")" ];

(* R615 *)
array-element = data-ref;
(* Constraint: in an array-element, every part-ref must have rank zero
               and the last part-ref must contain a subscript-list. *)

(* R616 *)
array-section = data-ref [ "(" substring-range ")" ] ;
(* Constraint: In array-section, exactly one part-ref must have nonzero rank,
               and either the final part-ref has a section-subscript-list
               with nonzero rank or another part-ref has a nonzero rank. *)
(* Constraint: In an array-section with a substring-range, the rightmost
               part-name must be of type character. *)

(* R617 *)
subscript = scalar-int-expr ;

(* R618 *)
section-subscript = subscript
                  | subscript-triplet
                  | vector-subscript ;

(* R619 *)
subscript-triplet = [subscript] ":" [subscript] [":" stride] ;

(* R620 *)
stride = scalar-int-expr ;

(* R621 *)
vector-subscript = int-expr ;
(* Constraint: vector-subscript must be  an integer array expression of
               rank 1 *)
```

Vector subscripts appear to be new to Fortran 90, the example from the
Standard is illuminating:

```f90
U = (/ 1, 3, 2 /)
V = (/ 2, 1, 1, 3 /)

Z(3, V) ! = (/ Z(3,2), Z(3,1), Z(3,1), Z(3,3) /)

Z(U, 2) ! = (/ Z(1,2), Z(3,2), Z(2,2) /)

Z(U, V) ! = (/ (/ Z(1,2), Z(1,1), Z(1,1), Z(1,3) /),
        !      (/ Z(3,2), Z(3,1), Z(3,1), Z(3,3) /),
        !      (/ Z(2,2), Z(2,1), Z(2,1), Z(2,3) /) /)
```

Recall:
- The "rank" of an array is the number of dimensions it has. Scalars
  have zero rank by convention.
- The "shape" of an array is a vector of integers, telling us the
  "extent" of [i.e., number of entries in] each dimension
- The "size" of an array is the total number of entries

```f90
! rank rexamples
INTEGER, DIMENSION (10) :: A     ! Rank = 1
REAL, DIMENSION (-5:5,100) :: B  ! Rank = 2

! shape examples
INTEGER, DIMENSION (10,10) :: A          ! Shape = (/ 10, 10 /)
REAL, DIMENSION (-5:4,1:10,10:19) :: B   ! Shape = (/ 10, 10, 10 /)

! size examples
INTEGER A(5)              ! Size = 5
REAL B(-1:0,1:3,4)        ! Size = 2 * 3 * 4 = 24
```
